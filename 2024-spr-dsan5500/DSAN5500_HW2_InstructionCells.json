{"1tHHwxMqCp9V": "# DSAN 5500 Homework 2: Data Structures, Algorithms, and Complexity\n\nSince we've now covered the Hash Table, and since you now have experience with the basics of how a Linked List is implemented, the goal of this homework is to **bring these two pieces of your knowledge together** by showing how:\n\n1. \"Na\u00efve\" Hash Tables, until they are **paired** with some minimally-efficient method for handling **collisions**, are not very useful on their own (Part 1)\n2. However, since we now know about Linked Lists, we can **use a Linked List structure within our Hash Table implementation** to achieve an actually-useful (non-na\u00efve) Hash Table achieving $O(1 + \\epsilon n)$ runtime (Part 2)\n3. Once you've seen how these two can be put together, we'll look at a **simple modification** we can make to the Linked List structure to create a **Binary Search Tree** structure, which can store and retrieve elements in $O(\\log_2(n))$ time, faster than the $O(n)$ runtime of the Linked List (Part 3)\n4. Then, once we've seen this Binary Search Tree Structure, we can return to our Hash Tables from Part 2 and **replace the Linked List structure being used to handle collisions** with a **Binary Search Tree structure instead**, to transform the Hash Table's runtime from $O(1 + \\epsilon n)$ to $O(1 + \\epsilon \\log_2(n))$ (Part 4)\n5. Finally, we will make one simple modification to our LogarithmicHashTable, using the first **two** letters of each key as the hash code (instead of just the first letter), which will bring us yet closer to full-on $O(1)$ time. This improvement illustrates how, by increasing the **memory** allocated for the fixed-length array in our hash table, we can get **arbitrarily close** to $O(1)$! (Part 5)", "_aDQcFjJDULM": "## Part 1: Na\u00efve Hash Tables (Without Collision Handling)\n\nOf all the parts on this assignment, this is the only one where you'll be making a structure that you would **not** want to use in real life! It's incredibly important for learning, however, since\n\n* (a) we'll see why a hash table **on its own**---that is, without any reasonably-efficient way to handle **collisions**---is not really a data structure at all (since it **loses information** that was previously added to it). However,\n* (b) we'll be able to use the code for our non-useful Na\u00efve Hash Table as the basis for a **useful Hash Table**, which you'll write in Part 2.\n\nFirst things first, however, we'll need a **hash function** which can take the **keys** we want to store in our hash table and deterministically derive a **slot** in our fixed-length array where a given key should be stored. To achieve this, run the following cell, which creates an `AlphaHasher` class that we'll use to hash `str` values. Specifically, this class will compute the hash value for a `str` as the **index in the alphabet** of the **first letter of the string**:\n\n* `\"Aardvark\"` will be mapped to `0` since `\"A\"` is the letter at index `0` of the English alphabet,\n* `\"Banana\"` will be mapped to `1` since `\"B\"` is the letter at index `1` in the English alphabet, and so on, up to...\n* `\"Zebra\"`, which will be mapped to `25` since `\"Z\"` is the letter at index `25` in the English alphabet.\n\nNote that, in Part 5, we'll switch from using `AlphaHasher` to using a new `DoubleAlphaHasher` class to hash based on the first **two** letters of the string, rather than just the first letter. While we'll stick to the pattern of having both `AlphaHasher` and `DoubleAlphaHasher` classes for now, since there are only two different versions, you can imagine how it could be helpful to **change the design pattern** we're using, to allow users to **specify** how many letters to use for hashing: rather than creating separate classes `AlphaHasher`, `DoubleAlphaHasher`, `TripleAlphaHasher`, etc., we could just create a single `NAlphaHasher` class which would allow users to specify how many letters of the string they want the hashing to use!", "ErETIN8aBmBp": "# @title define-alpha-hasher\nfrom abc import ABC, abstractmethod\nimport string\n\nclass CustomHasher(ABC):\n  @abstractmethod\n  def __init__(self):\n    pass\n\n  @abstractmethod\n  def get_alphabet_size(self):\n    pass\n\n  @abstractmethod\n  def hash(self, str_to_hash: str) -> int:\n    pass\n\n  @abstractmethod\n  def compute_position_in_alphabet(self, uppercase_key: str) -> int:\n    pass\n\n  @abstractmethod\n  def compute_key_for_index(self, index: int) -> str:\n    pass\n\nclass AlphaHasher(CustomHasher):\n  def __init__(self):\n    self.alphabet_size = 26\n\n  def get_alphabet_size(self):\n    return self.alphabet_size\n\n  def hash(self, str_to_hash: str) -> int:\n    if len(str_to_hash) == 0:\n      first_letter = 'A'\n    else:\n      first_letter = str_to_hash.upper()[0]\n    # And return its index in the alphabet:\n    # 'A' has index 0, 'B' has index 1, etc.\n    return self.compute_position_in_alphabet(first_letter)\n\n  def compute_position_in_alphabet(self, uppercase_key: str) -> int:\n    return string.ascii_uppercase.index(uppercase_key)\n\n  def compute_key_for_index(self, index: int) -> str:\n    return string.ascii_uppercase[index]", "6iUXyb6VV53c": "### Question 1.1: The `NaiveHashTable` Class\n\nIn the following cell, build on the provided starter code to create a working `NaiveHashTable` class. Each of the bullet points here represents an element of this class that your code should implement.\n\n* `__init__(self) -> None`. This **constructor** function should take only the required `self` argument, but will also perform the following initialization steps, which are already written for you:\n  * Create an **instance variable** called `fixed_length_array`, whose value should be initialized to an **empty NumPy array** object with size `26` (for the 26 \"slots\" in the English alphabet). Specifically, we create this empty array using NumPy's <a href='https://numpy.org/doc/stable/reference/generated/numpy.empty.html' target='_blank'>`np.empty()` function</a>.\n  * Create an **instance variable** called `num_added`, initialized to the `int` value `0` (this will be incremented each time the `add()` function runs)\n  * Create an **instance variable** called `num_collisions`, initialized to the `int` value `0` (this will be incremented each time the `add()` function encounters a collision)\n* `add(key: str, value: object) -> bool`\n\n  This function should:\n\n  1. Create a variable called `data` and assign the tuple `(key, value)` as its value,\n  2. **Use the `hash()` function from `AlphaHasher`** to **hash** the value of the `key` argument, storing this hashed value (which will be of type `int`) into a variable called `key_hash`. However, here you will need to be careful and include a **check** to determine whether or not the variable `key` is in fact a **string**. If `key` is an **instance of** the `str` type, then your code can safely call `hash(key)` without issue. If it is not, however, your function should **not** try to call `hash(key)`, and should instead just return the `bool` value `False`. Thus, users of your `NaiveHashTable` class will know that if the `add()` function returned `False` it means the `key` they provided was **not hashable** given our `AlphaHasher` setup.\n\n    Note how we *can* (and should!) include a `str` **type hint** for the `key` argument in the specification of `add()` above, but since Python does not **enforce** type hints, we still ask you to perform this check within the `add()` function. The rationale for this is: if you are developing **for yourself** or in a **small team**, you can either (a) trust yourself and your teammates to look at and never violate the type hints, **or** (b) set up your personal/team development environment so that it **runs a type-checker like MyPy** on each `.py`/`.ipynb` file before running it. For larger collaborative projects, however (for example, the many popular open-source projects with hundreds of contributors on GitHub), it will almost **never** be the case that they run MyPy before running Python code, sadly!\n  3. If the function did not return `False` during the previous step, and we were able to successfully compute a hash value for `key`, then store the `(key, value)` tuple (the value assigned to the variable `data` in Step 1) in the specific \"slot\" within `base_array` with index `key_hash`. For example: if the value of `key_hash` is `0`, store the tuple as the **first** element of `self.fixed_length_array`; if the value of `key_hash` is `1`, store the tuple as the **second** element of `fixed_length_array`; and so on. However, here you will need to be careful to **check whether there was a collision or not!** If the previous value in the slot **was not `None`**, then there has been a **collision**, so that you should **increment the `self.num_collisions` instance variable** before you replace the previous value in the slot with the new value!\n  4. Once the slot within `self.fixed_length_array` has been updated, make sure to also **increment the `self.num_added` instance variable**. By tracking the number of collisions at the end of Step 3, and tracking the number of items added in this step, the `compute_collision_rate()` function described below should only require 1 or 2 lines of code!\n* `get_item_at_index(self, index: int) -> object`\n  * This function should just return whatever happens to be stored in slot `index` of the `fixed_length_array` instance variable. So, `get_item_at_index(0)` should return `self.fixed_length_array[0]`, `get_item_at_index(1)` should return `self.fixed_length_array[1]`, and so on. You should implement this **before** using `to_string()`, however, since `to_string()` uses this function to **display the entries within each slot of `self.fixed_length_array`**.\n* `__len__(self) -> int`\n  * This function should just return the number of **slots** within `self.fixed_length_array` that contain non-`None` values. In other words, it should return the number of **\"filled\" slots** in the hash table. Note that this is **not the same as `num_added`**!! This is important to notice here since, it's precisely why our `NaiveHashTable` is not a usable data structure (yet): when the `add()` function encounters a **collision**, the previously-stored value is **thrown out** and replaced by a new value. This means that, for example, the user may have added 20 items to the `NaiveHashTable`, but `__len__()` may only return `16`, indicating that there were **4 collisions** among the 20 calls to `add()`!\n* `compute_collision_rate(self) -> float`\n  * This function should use the `num_added` and `num_collisions` instance variables to compute the **collision rate** for the `NaiveHashTable` object. If **no items have been added yet** (i.e., if the `NaiveHashTable` object is empty), this function should just return the `float` value `0.0`. However, as long as the object has one or more entries, this function should return the **ratio** of the **number of collisions** to the **number of successful calls to `add()`** (there are two instance variables you defined in the constructor which will help you here \ud83d\ude1c)\n* `__str__(self) -> str` and `__repr__() -> str`\n  * The starter code defines an **instance method** for you, within the `NaiveHashTable` class, called `to_string()`. Your `NaiveHashTable` should implement both the `__str__()` and `__repr__()` functions, but all that these two functions need to do is simply **return the result of calling `self.to_string()`**.\n\n  The `to_string()` function here allows us to straightforwardly visualize the contents of our `NaiveHashTable`: it will always produce exactly 26 lines, where each line corresponds to a \"slot\" in our `fixed_length_array`, showing the alphabetical letter that hashes to the slot and then the value stored in that slot. For example, if we've added the three datapoints `('Aardvark', 10)`, `('Popsicle', 20)`, and `('Coconut', 30)` in a `NaiveHashTable` object `naive_ht`, then `naive_ht.to_string()` will produce the following output:\n\n  ```\n  A: ('Aardvark', 10)\n  B: None\n  C: ('Coconut', 30)\n  D: None\n  E: None\n  F: None\n  G: None\n  H: None\n  I: None\n  J: None\n  K: None\n  L: None\n  M: None\n  N: None\n  O: None\n  P: ('Popsicle', 20)\n  Q: None\n  R: None\n  S: None\n  T: None\n  U: None\n  V: None\n  W: None\n  X: None\n  Y: None\n  Z: None\n  ```\n\n  In the remaining parts of the assignment, having this `to_string()` function will serve another important purpose, but for now it simply allows us to \"unify\" the `__repr__()` and `__str__()` implementations into a single function.", "TLgtgUa7VyKn": "# @title Q1.1-solution\nimport collections\nimport sys\nimport numpy as np\n\nclass NaiveHashTable:\n  def __init__(self):\n    self.hasher = AlphaHasher()\n    self.fixed_array_size = self.hasher.get_alphabet_size()\n    self.fixed_length_array = np.empty(self.fixed_array_size, dtype='object')\n    self.num_added = 0\n    self.num_collisions = 0\n\n  def add(self, key: str, value: object) -> bool:\n    if not isinstance(key, str):\n      return False\n    data = (key, value)\n    key_hash = self.hasher.hash(key)\n    # First increment the total added\n    self.num_added = self.num_added + 1\n    # Check if an element already exists in the slot\n    already_filled = self.fixed_length_array[key_hash] is not None\n    if already_filled:\n      self.num_collisions = self.num_collisions + 1\n    self.fixed_length_array[key_hash] = data\n\n  def get_num_added(self):\n    return self.num_added\n\n  def increment_num_added(self):\n    self.num_added = self.num_added + 1\n\n  def get_num_collisions(self):\n    return self.num_collisions\n\n  def increment_num_collisions(self):\n    self.num_collisions = self.num_collisions + 1\n\n  def get_item_at_index(self, index: int) -> object:\n    return self.fixed_length_array[index]\n\n  def compute_collision_rate(self) -> float:\n    if self.get_num_added() == 0:\n      return 0.0\n    return self.get_num_collisions() / self.get_num_added()\n\n  def __len__(self):\n    return sum(self.fixed_length_array != None)\n\n  def to_string(self):\n    entry_list = [f'{self.hasher.compute_key_for_index(i)}: {self.get_item_at_index(i)}' for i in range(len(self.fixed_length_array))]\n    return \"\\n\".join(entry_list)\n\n  def __str__(self):\n    return self.to_string()\n\n  def __repr__(self):\n    return self.__str__()", "LqoqrjO8K5DJ": "Since \"hiding\" the public tests in the last assignment probably did more harm than good, this time the public tests are **fully revealed** and **commented**, so that you can see exactly **why** we're testing certain aspects of your code, and especially **how** we're testing them! I hope this can help with transparency: if you're failing one of the public tests, but you can't figure out why based on the message, you can **expand** the public test cells to see exactly which line(s) your response is failing on.", "WmSUECRDLWbC": "# @title Q1.1-public\nimport inspect\ndef test_len():\n  test_naive_ht = NaiveHashTable()\n  test_len = len(test_naive_ht)\n  return test_len < sys.maxsize, test_len\nlen_test_result, len_test_value = test_len()\n\ndef test_collisions():\n  test_naive_ht = NaiveHashTable()\n  test_naive_ht.add('Penguin', 30)\n  len_pre = len(test_naive_ht)\n  test_naive_ht.add('Platypus', 40)\n  len_post = len(test_naive_ht)\n  return len_pre == len_post\ncollision_test_result = test_collisions()\n\n# Test 1: is a NaiveHashTable defined at all?\nassert 'NaiveHashTable' in vars(), 'No NaiveHashTable class in Python memory'\n# Test 2: __str__() and __repr__() should both just call to_string()\nassert 'to_string' in inspect.getsource(NaiveHashTable.__str__), '__str__() and __repr__() functions should both call to_string()'\n# Test 3: __len__() returns valid int value\nassert len_test_result, f'Invalid return value for __len__(): {len_test_value}'\n# Test 4: Length shouldn't increase on collisions (since the existing value in slot gets \"kicked out\")\nassert collision_test_result, 'Length of NaiveHashTable should not change before and after collision'\n", "sqwygS8EnidE": "### Part 1.2: Testing Basic Functionality of `NaiveHashTable`\n\nThis part will walk you through some basic tests you can run, to make sure that your implementation is **tracking the collision rate** correctly (by tracking the `num_added` and `num_collisions` instance variables correctly).\n\nAlthough there are public and hidden tests for this part, you should be able to tell in advance what the correct answers are, based on the instructions! (e.g., you know in advance that, before any (key, value) pairs are added to the hash table, the collision rate should be `0.0`)", "1GI5e7G52JVK": "#### Question 1.2.1\n\n* (a) Create a new `NaiveHashTable` object called `naive_ht_demo`, and then\n* (b) Call the `get_num_added()` function on `naive_ht_demo` and store its return value in a variable called `added0`,\n* (c) Call the `get_num_collisions()` function on `naive_ht_demo` and store its return value in a variable called `collisions0`,\n* (d) Call the `compute_collision_rate()` function on `naive_ht_demo` and store its return value in a variable called `rate0`.", "mTlXggpe1EJb": "# @title Q1.2.1-solution\nnaive_ht_demo = NaiveHashTable()\nadded0 = naive_ht_demo.get_num_added()\ncollisions0 = naive_ht_demo.get_num_collisions()\nrate0 = naive_ht_demo.compute_collision_rate()", "InrsZd-g3zN1": "# @title Q1.2.1-public\n# Test 1: Check if naive_ht_demo variable is defined (in Python memory)\nassert 'naive_ht_demo' in vars(), \"\u274c No variable named 'naive_ht_demo' exists in Python memory\"\n# Test 2: Check if added0 defined\nassert 'added0' in vars(), \"\u274c No variable named 'added0' exists in Python memory\"\n# Test 3: Check if collisions0 defined\nassert 'collisions0' in vars(), \"\u274c No variable named 'collisions0' exists in Python memory\"\n# Test 4: Check if rate0 defined\nassert 'rate0' in vars(), \"\u274c No variabled named 'rate0' exists in Python memory\"", "uoQyZGxS2mOs": "#### Question 1.2.2\n\n* (a) Add a new datapoint, mapping the `str` key `'Kitten'` to the `int` value `10`, to `naive_ht_demo`,\n* (b) Call the `get_num_added()` function on `naive_ht_demo` again, storing the new value into a variable called `added1`,\n* (c) Call the `get_num_collisions()` function on `naive_ht_demo` again, storing the new value into a variable called `collisions1`, and\n* (d) call the `compute_collision_rate()` function on `naive_ht_demo` again, storing the new value into a variable called `rate1`", "GJPF_vY32lnB": "# @title Q1.2.2-solution\nnaive_ht_demo.add('Kitten', 10)\nadded1 = naive_ht_demo.get_num_added()\ncollisions1 = naive_ht_demo.get_num_collisions()\nrate1 = naive_ht_demo.compute_collision_rate()", "h8w35Eau32cC": "# @title Q1.2.2-public\n# Test 1: Check if added1 defined\nassert 'added1' in vars(), \"\u274c No variable named 'added1' exists in Python memory\"\n# Test 2: collisions1 defined\nassert 'collisions1' in vars(), \"\u274c No variable named 'collisions1' exists in Python memory\"\n# Test 3: rate1 defined\nassert 'rate1' in vars(), \"\u274c No variable named 'rate1' exists in Python memory\"", "Pfhb8vp83Rrb": "#### Question 1.2.3\n\n* (a) Add another new datapoint, this time mapping the `str` key `'Koala'` to the `int` value `8`, to `naive_ht_demo`.\n* (b) Call the `get_num_added()` function on `naive_ht_demo` once more, and store its return value into a variable named `added2`.\n* (c) Call the `get_num_collisions()` function on `naive_ht_demo` once more, and store its return value into a variable called `collisions2`, and\n* (d) Call the `compute_collision_rate()` function on `naive_ht_demo` once more, and store its return value into a variable called `rate2`.", "lyjLoXXl35iE": "# @title Q1.2.3-solution\nnaive_ht_demo.add('Koala', 8)\nadded2 = naive_ht_demo.get_num_added()\ncollisions2 = naive_ht_demo.get_num_collisions()\nrate2 = naive_ht_demo.compute_collision_rate()", "SGjLnJjF3851": "# @title Q1.2.3-public\n# Test 1: Check if added2 defined\nassert 'added2' in vars(), \"\u274c No variable named 'added2' exists in Python memory\"\n# Test 2: Check if collisions2 defined\nassert 'collisions2' in vars(), \"\u274c No variable named 'collisions2' exists in Python memory\"\n# Test 3: Check if rate2 defined\nassert 'rate2' in vars(), \"\u274c No variable named 'rate2' exists in Python memory\"", "W9Xy8xg0096F": "### Part 1.3: Using `NaiveHashTable` with Real Data\n\nThe questions in this part will help illustrate (a) how to use the class we just made to store real-world data, but also (b) why it fails as a workable data structure in its current form!", "IxNMKnHR1ZUu": "#### Question 1.3.1\n\nCreate a new `NaiveHashTable` object, assigning it as the value for a variable named `naive_ht_real`.", "FVrq8sp90-1w": "# @title Q1.3.1-solution\nnaive_ht_real = NaiveHashTable()", "wgjFb4iX4vGq": "# @title Q1.3.1-public\n# Test 1: Check if naive_ht_real defined\nassert 'naive_ht_real' in vars(), \"\u274c No variable named 'naive_ht_real' exists in Python memory\"", "pp2NDv4c2I2Z": "#### Question 1.3.2\n\nContinuing with our **cashier example** from class, run the following code, which\n\n* (a) loads data from a `.csv` file containing names and prices for 50 randomly-sampled items from Walmart's inventory and\n* (b) stores this data within a Pandas `DataFrame` object named `walmart_df`:", "m77xguDFzrXP": "# @title Q1.3.2-solution\nimport pandas as pd\nwalmart_df = pd.read_csv(\"https://jpj.georgetown.domains/dsan5500-scratch/walmart.csv\")\nwalmart_df.head()", "0e38L3Thd3zT": "# @title Q1.3.2-public\n# Test 1: Check if walmart_df defined\nassert 'walmart_df' in vars(), \"\u274c No variable named 'walmart_df' exists in Python memory\"\n# Test 2: Check if walmart_df has correct length\nassert len(walmart_df) == 50, f\"\u274c walmart_df DataFrame length ({len(walmart_df)}) is incorrect\"", "OVhaqtRm2lh9": "#### Question 1.3.3\n\nUsing the `iterrows()` function (which is available for all Pandas `DataFrame` objects), write a `for` loop which iterates over each row of `walmart_df`, carrying out the following steps within each loop iteration\n\n1. Store the current row's `item_name` value as a Python variable called `cur_name`\n2. Store the current row's `price` value as a Python variable called `cur_price`\n3. Add a new entry to the `naive_ht_real` object (using the `add()` function that you wrote above), mapping the key `cur_name` to the value `cur_price`.", "VXWkrQxKH3_B": "# @title Q1.3.3-solution\nfor row_index, cur_row in walmart_df.iterrows():\n  cur_name = cur_row['item_name']\n  cur_price = cur_row['price']\n  naive_ht_real.add(cur_name, cur_price)", "K1eT1Ar2455c": "# @title Q1.3.3-public\nnht_added_result = None\nif 'naive_ht_real' in vars() and naive_ht_real is not None:\n  nht_added_result = naive_ht_real.get_num_added()\n# Test 1: Check that get_num_added() returns the correct value for naive_ht_real\nassert nht_added_result == 50, f'\u274c naive_ht_real.get_num_added() should return 50. Current return value: {nht_added_result}'", "_WDeKVtyH6ZE": "#### Question 1.3.4\n\nIf the above steps were implemented correctly, you should now be able to run the following cell to see the result of the `__repr__()` function of your `naive_ht_real` object. You should see *some*, though not *all* of the data tuples that you added to `naive_ht_real` over the course of the for loop in the previous question:", "2ozrlVObIDzT": "# @title Q1.3.4-solution\nif 'naive_ht_real' in vars():\n  display(naive_ht_real)\nnaive_ht_real", "8vvkcbLX5J2e": "# @title Q1.3.4-public\nassert True", "mh9xgy88IaQG": "#### Question 1.3.5\n\nAs the final step for this part:\n\n* (a) Calculate the number of records in the **original** dataset by calling `len()` with `walmart_df` as its argument, storing its return value into a Python variable named `len_original`. Then\n* (b) Calculate the number of records which were **retained** in `naive_ht_real` by calling `len()` again with `naive_ht_real` as its argument, storing its return value into a Python variable named `len_naive_ht`.\n\nThe value in `len_naive_ht` should exactly match the number of tuples displayed in the output of the previous question, but should **not** match the value of `len_original` (since collisions should have resulted in previously-stored items being \"kicked out\" of the hash table).", "w_T2kbT0I1ag": "# @title Q1.3.5-solution\nlen_original = len(walmart_df)\nlen_naive_ht = len(naive_ht_real)", "qr0iUPuZI3JQ": "# @title Q1.3.5-public\n# Test 1: Check if len_original defined\nassert 'len_original' in vars(), \"\u274c No variable named 'len_original' exists in Python memory\"\n# Test 2: Check if len_naive_ht defined\nassert 'len_naive_ht' in vars(), \"\u274c No variable named 'len_naive_ht' exists in Python memory\"", "ykCNcIUwDYY6": "## Part 2: Hash Tables with Linear Collision Handling\n\nIn the previous part you saw how the Na\u00efve Hash Table is not very useful on its own, since it **throws away** information that was previously added to it whenever a collision occurs!\n\nIn this part, you'll **solve** this problem and **transform** your Na\u00efve Hash Table into a usable **(Linear) Hash Table**.\n\nWhereas in Part 1 you handled collisions by simply throwing away the old data and replacing it with the new data, in this part you will instead **change** the type of value stored in a slot when a collision occurs.\n\nFirst things first, however, you're going to need a completed **Linked List** implementation! Run the next cell, which defines a fully-implemented polymorphic linked list (so, a slightly fancier version of the `LinkedList` class you implemented for HW1!). You can look through the code here, to understand how it works, but you can also just run it and move on to the next part of this question!", "IRvVe7eH5wm2": "# @title define-linked-list\nfrom abc import ABC, abstractmethod\n\nclass LinkedList:\n  def __init__(self):\n    self.root = EmptyNode()\n\n  def append(self, item):\n    self.root = self.root.append(item)\n\n  def find_item_steps(self, item):\n    return self.root.find_item_steps(item)\n\n  def to_string(self, recurse: bool):\n    return f'LinkedList[{self.root.to_string(recurse)}]'\n\n  def __len__(self):\n    return len(self.root) # Added 2024-02-22\n\n  def __repr__(self):\n    return self.to_string(recurse=True)\n\n  def __str__(self):\n    return self.to_string(recurse=False)\n\nclass PolymorphicNode(ABC):\n  @abstractmethod\n  def __init__(self):\n    pass\n\n  @abstractmethod\n  def append(self, item):\n    pass\n\n  @abstractmethod\n  def find_item_steps(self, item):\n    pass\n\n  @abstractmethod\n  def to_string(self, recurse: bool):\n    pass\n\n  def __repr__(self):\n    return self.to_string(recurse=True)\n\n  def __str__(self):\n    return self.to_string(recurse=False)\n\nclass EmptyNode(PolymorphicNode):\n  def __init__(self):\n    super().__init__()\n\n  def append(self, item):\n    \"\"\"\n    This is the only weird part of EmptyNode: because we want to utilize\n    *polymorphism*, when append() is called on an EmptyNode it\n    is \"transformed into\" a FilledNode! That is why, in the\n    LinkedList's append() function, we have self.root = self.root.append(),\n    and why the FilledNode's append() function works the same way\n    \"\"\"\n    #print(\"EmptyLinkedListNode.append()\")\n    new_form = ContentNode(item)\n    return new_form\n\n  def find_item_steps(self, item):\n    return np.inf\n\n  def __len__(self):\n    return 0\n\n  def to_string(self, recurse: bool):\n    return ''\n\nclass ContentNode(PolymorphicNode):\n  def __init__(self, content_arg):\n    super().__init__()\n    self.content = content_arg\n    self.next = EmptyNode()\n\n  def append(self, item):\n    self.next = self.next.append(item)\n    # Return just *self*, since we *haven't* transformed the type of\n    # FilledLinkedListNode by appending another element to it\n    return self\n\n  def find_item_steps(self, item):\n    if self.content == item or self.content[0] == item:\n      return 1\n    return 1 + self.next.find_item_steps(item)\n\n  def get_content(self):\n    return self.content\n\n  def __len__(self):\n    return 1 + len(self.next)\n\n  def to_string(self, recurse: bool):\n    content_str = f'ContentNode[{str(self.get_content())}] '\n    if not recurse:\n      return content_str\n    return f'{content_str}{self.next.to_string(recurse)}'\n\n  def to_string(self, recurse: bool):\n    content_str = f'ContentNode[{str(self.get_content())}] '\n    if not recurse:\n      return content_str\n    return f'{content_str}{self.next.to_string(recurse)}'\n", "4_8_DlXZoJ2h": "To further help you in working with this version of `LinkedList` (though, again, you can move immediately to the question if you feel comfortable with how the `LinkedList` works!), you can run the following cell which defines a `visualize_ll()` function that takes in an object of type `LinkedList` and produces a visualization of its contents, in the same form that I've used to draw linked lists on the board during class!", "2fzIIjcWoJkp": "# @title define-linkedlist-visualizer\nfrom IPython.display import display\nimport graphviz as gv # for visualizing a tree using Digraph\nfrom graphviz import Digraph, nohtml\n\ndef visualize_ll(ll):\n  dot = Digraph(\n      graph_attr={'rankdir': 'LR'},\n        node_attr={'shape': 'record', 'height': '.1'}\n    )\n  prev_node_name = None\n  node_pointer = ll.root\n  while type(node_pointer) != EmptyNode:\n    # New node\n    cur_name = node_pointer.content\n    dot.node(name=cur_name, label=nohtml('{<f0> '+cur_name+'|<f1>}'))\n    # And edge from prev to cur, if not None\n    if prev_node_name is not None:\n      edge_from = f'{prev_node_name}:f1'\n      dot.edge(edge_from, cur_name)\n    # Now we can update prev_node_name\n    prev_node_name = cur_name\n    node_pointer = node_pointer.next\n  display(dot)\n\n# Create (empty) list\nprint(\"Empty LL:\")\npll = LinkedList()\nprint(pll.__str__())\nprint(pll.__repr__())\nprint(type(pll))\nprint(type(pll.root))\n# Add an element\nprint(\"\\nAdding 'a':\")\npll.append('a')\nprint(pll.__str__())\nprint(pll.__repr__())\nprint(type(pll))\nprint(type(pll.root))\n# And a second\nprint(\"\\nAdding 'z':\")\npll.append('z')\nprint(pll.__str__())\nprint(pll.__repr__())\nprint(type(pll))\nprint(type(pll.root))\nprint(\"\\n---\\n\")\n\nvisualize_ll(pll)", "4uPTV2ugI9VY": "### Question 2.1: The `LinearHashTable` Class\n\nIn the following cell, implement a class called `LinearHashTable`, which should work similarly to the `NaiveHashTable` from the previous part **except in the case where a collision occurs during execution of the `add()` function!**\n", "AwMWv7cl6r_X": "To see how this **polymorphic** `LinkedList` class works, you can run the following cell, which illustrates its polymorphic nature:\n\n* When a new, empty `LinkedList` object is first created, its `root` pointer points to an object of type `EmptyNode`.\n* But then, once a first element is **added** to the `LinkedList`, the value that `root` points to is **transformed** from an `EmptyNode` object to a `ContentNode` object.\n* Since this transformation happens automatically (specifically: since the `add()` function within the `EmptyNode` class returns a `ContentNode` object), we no longer need **if statements** checking whether or not `root` points to `None`!\n\nFor now this structure might seem like overkill---creating this polymorphic structure just to get rid of a few if statements---but it will become more and more important to think in this way as we create data structures with \"fancier\" types of **nodes**: the `BinarySearchTree` in the next part, for example, has **two** pointers (`left` and `right` rather than just `next`), and the `QuadTree` that we'll look at later will have **four** pointers (`nw`, `ne`, `sw`, `se`). So, if you can get comfortable with this polymorphic structure now, you'll eliminate the need for **two** if statements within every function of the `BinarySearchTree` class, **four** if statements within every function of the `QuadTree` class, and so on!", "suxETa_H5xAF": "Now that the `LinkedList` class is defined, we can use it as a \"black box\" within our `LinearHashTable` class! In the following cell, implement this `LinearHashTable` class, by writing the following functions:\n\n* `__init__(self)`: Just like in Part 1, the constructor for `LinearHashTable` should just initialize an instance variable called `fixed_length_array`, as a NumPy array with length 26. It should also initialize, as in the `NaiveHashTable` class, instance variables called `num_added` and `num_collisions`, both of which should be assigned the `int` value `0`.\n* `add(self, key: str, value: object) -> bool`: Now that we're moving from a **Na\u00efve** Hash Table to a **Linear** Hash Table, your `add()` function will become a bit more involved: it will need to check whether `key` is indeed a variable of type `str`, returning the `bool` value `False` if it is not, and then it will hash the `key` object as before. However, after computing this hash value for `key`, you will need to handle three possible cases:\n  * **[Case 1] `key` hashes to empty slot**: If the entry at index `key_hash` of `self.fixed_length_array` is just the value `None`, you just need to update this entry to now be a `tuple` object `(key, value)`.\n  * **[Case 2] `key` hashes to a slot containing a single `tuple` object**: If the entry at index `key_hash` of `self.fixed_length_array` is a `tuple` object (meaning, something was hashed into this slot before, triggering [Case 1], and thus we now have a first **collision** at this slot), then you will need to (a) store the existing `tuple` object into a Python variable (so it is not lost in this conversion), (b) construct a new `LinkedList` object for storing the two datapoints that have now been hashed to the same slot (and any further values that may hash to this same slot, handled in [Case 3]), (c) add the `tuple` object that was originally in this slot as the **first** item in the `LinkedList` you just created, and (d) add a new tuple `(key, value)` containing the data currently being added (the arguments to the `add()` function) as the **second** item in this newly-constructed `LinkedList`.\n  * **[Case 3] `key` hashes to a slot containing a `LinkedList` object**: If the entry at index `key_hash` of `self.fixed_length_array` is a `LinkedList` object (meaning, two or more keys have already previously hashed into this same slot), you just need to create a tuple object `(key, value)` containing the data currently being added (the arguments to the `add()` function), and append this tuple object as the **next item** within the existing `LinkedList` object.\n* `find_item_steps(self, key: str)`: The code for this function has already been provided for you, but I wanted to include it here because it will be important to understand, since it's what we will use to measure the **efficiency** of our hash table, in this and future parts of the assignment. This function uses the `AlphaHasher` class to compute the hash value `key_hash` for the `key` argument, then returns different values given three different possible cases:\n  * **[Case 1] The content at index `key_hash` is just the value `None`**: This means that an entry with key `key` does not exist in the hash table (since, if it did, that entry would have hashed to the slot `key_hash`, and thus this slot would not contain `None`), so to indicate that we only had to do this one computational step (checking the value in slot `key_hash`) to discover that the entry does not exist, we return the `int` value `1`\n  * **[Case 2] The content at index `key_hash` is a `tuple` object**: This means that only one entry has ever hashed into this slot, so we've either (a) found the item with key `key`, if the first element of the tuple is equal to `key`, or (b) discovered that the item does not exist in the hash table, if the first element of the tuple is not equal to `key`. Therefore, in either case we've only performed **one** computational step, so we return the `int` value `1`.\n  * **[Case 2] The content at index `key_hash` is a `LinkedList` object**: In this case we \"forward\" the function to the `LinkedList` class, by just returning the value produced as a result of calling the `find_item_steps()` function on the `LinkedList` object at index `key_hash`. This function is implemented within the `LinkedList` class provided for you above, and computes how many \"hops\" were required before finding the node corresponding to the desired `key` value.\n* `entry_to_string(self, index: int, recurse: bool) -> object`: You need to complete this function, but it just asks you to return whatever value is stored within the instance variable `self.fixed_length_array` at slot `index`. In other words, you **do not need to do any hashing for this function**: whereas the other functions have an argument like `key` (indicating a value that should be hashed for insertion/retrieval into the hash table), this function just needs to directly go to the slot `index` and return its value. So, we have the following (hopefully) straightforward cases, where [Case 3] is the only one requiring an additional consideration:\n  * **[Case 1] The entry at slot `index` is `None`**: In this case, the function should return the value `None`\n  * **[Case 2] The entry at slot `index` is a `tuple` object**: In this case, the function should just return this `tuple` object.\n  * **[Case 3] The entry at slot `index` is a `LinkedList`**: This is the case you need to be careful about, because it's where the `recurse` argument comes in. The `LinkedList` class provided for you above has a `to_string()` function defined, which takes in a single argument called `recurse`, and prints **all** contents of the list if the provided `recurse` value is `True`, or just the **first** item in the list if the provided `recurse` value is `False`. Your code here, therefore, just needs to return the value which is produced by calling the `to_string()` function on the `LinkedList` object stored in the slot `index`, with the `recurse` value as its only argument. This ensures that, for example, if `entry_to_string()` was called with a `recurse` value of `True` and the entry in slot `index` is a `LinkedList` object, the full contents of this `LinkedList` object will be produced.\n* `__len__(self) -> int`: Notice the two underscores before and after the name of this function: this indicates that it is a **special** function used by Python to implement some operator, in this case the `len()` operator.  So, your job in implementing this function is to return an `int` value representing the total number of elements stored in the hash table. Note that, **unlike the case for the `NaiveHashTable`**, here you cannot simply count the number of empty vs. non-empty slots! Instead, any time you encounter a slot in the `self.fixed_length_array` instance variable that contains a `LinkedList` object, you will need to use the `len()` operator (which we know will \"work\", since `__len__()` is defined within the provided `LinkedList` class above) to find its length. Given this, hopefully it makes sense that the final length of the **entire `LinearHashTable`** will be the sum of:\n  * `0` for all slots containing just the \"blank\" value `None`\n  * `1` for all slots containing a single `tuple` object, and\n  * `len(self.fixed_length_array[i])` for all slots `i` containing a `LinkedList` object.\n* `__str__()` and `__repr__()`: As before, you do need to implement these functions, but they should just work as follows:\n  * `__str__()` should return the value of `self.to_string()`, called with the `recurse` argument set to be the `bool` value `False`\n  * `__repr__()` should return the value of `self.to_string()`, called with the `recurse` argument set to be the `bool` value `True`\n\nBy implementing `__str__()` and `__repr__()` this way, we can see our first real example of using these two functions for two different purposes:\n* We use `__str__()` to generate a **simplified** string representation of the `LinearHashTable` object, where we only see the first element of any slots containing `LinkedList` objects, but then\n* We use `__repr__()` to generate an **expanded** (i.e., more detailed) string representation of the `LinearHashTable` object, where we see **all** of the elements stored within any slots containing `LinkedList` objects.", "E3wOOH4lgfMT": "# @title Q2.1-solution\nfrom abc import ABC\nimport numpy as np\n\nclass LinearHashTable:\n  def __init__(self):\n    self.hasher = AlphaHasher()\n    self.fixed_array_size = self.hasher.get_alphabet_size()\n    self.fixed_length_array = np.empty(self.fixed_array_size, dtype='object')\n    self.num_added = 0\n    self.num_collisions = 0\n\n  def add(self, key: str, value: object) -> bool:\n    if not isinstance(key, str):\n      return False\n    data = (key, value)\n    key_hash = self.hasher.hash(key)\n    if self.fixed_length_array[key_hash] is None:\n      # All good, we can add without collision\n      self.fixed_length_array[key_hash] = data\n      self.num_added = self.num_added + 1\n      return True\n    if isinstance(self.fixed_length_array[key_hash], LinkedList):\n      # Already a collision previously, so LinkedList has already been set up;\n      # This is another collision, but we can just add to the existing LinkedList\n      self.increment_num_collisions()\n      self.fixed_length_array[key_hash].append(data)\n      self.increment_num_added()\n      return True\n    # If we're here, it's a collision *but* the first collision in this slot;\n    # so, we need to set up the LinkedList, add the item currently in the slot\n    # as its first element, then add `data` as its second element\n    self.increment_num_collisions()\n    original_data = self.fixed_length_array[key_hash]\n    self.fixed_length_array[key_hash] = LinkedList()\n    self.fixed_length_array[key_hash].append(original_data)\n    self.fixed_length_array[key_hash].append(data)\n    self.increment_num_added()\n    return True\n\n  def find_item_steps(self, key: str) -> int:\n    key_hash = self.hasher.hash(key)\n    if self.fixed_length_array[key_hash] is None:\n      return 1\n    if isinstance(self.fixed_length_array[key_hash], LinkedList):\n      return self.fixed_length_array[key_hash].find_item_steps(key)\n    return 1\n\n  def entry_to_string(self, index: int, recurse: bool) -> object:\n    item_at_index = self.fixed_length_array[index]\n    if item_at_index is None:\n      return None\n    if isinstance(item_at_index, tuple):\n      return item_at_index\n    return item_at_index.to_string(recurse)\n\n  def get_num_added(self):\n    return self.num_added\n\n  def increment_num_added(self):\n    self.num_added = self.num_added + 1\n\n  def get_num_collisions(self):\n    return self.num_collisions\n\n  def increment_num_collisions(self):\n    self.num_collisions = self.num_collisions + 1\n\n  def __len__(self):\n    total_len = 0\n    for cur_item in self.fixed_length_array:\n      if cur_item is None:\n        continue\n      elif isinstance(cur_item, tuple):\n        total_len = total_len + 1\n      else:\n        total_len = total_len + len(cur_item)\n    return total_len\n\n  def to_string(self, recurse):\n    entry_list = [f'{self.hasher.compute_key_for_index(i)}: {self.entry_to_string(i, recurse)}' for i in range(len(self.fixed_length_array))]\n    return \"\\n\".join(entry_list)\n\n  def __repr__(self):\n    return self.to_string(recurse=True)\n\n  def __str__(self):\n    return self.to_string(recurse=False)\n", "OptA67lmSVC2": "# @title Q2.1-public\n# Test 1: Check if LinearHashTable definition is in Python's memory\nassert 'LinearHashTable' in vars(), \"\u274c 'LinearHashTable' class definition not in Python memory\"", "12meeyFf7eIE": "### Part 2.2: Using `LinearHashTable` to Store Real Data", "wzK3Cr0W7jmo": "The following code loads a new dataset (different from the dataset used in Part 1), containing randomly-generated data from Mockaroo on $N = 1000$ products and their prices, into a Pandas `DataFrame` object called `product_df`. You can take a look at the contents, for concrete examples of the data we're going to add to our `LinearHashTable` (where they will be stored, internally, as `tuple` objects)", "YZxp2Axk7ikM": "import pandas as pd\nproduct_df = pd.read_csv(\"https://jpj.georgetown.domains/dsan5500-scratch/mockaroo.csv\")\nproduct_df.head()", "QuF4CMTf78tA": "#### Question 2.2.1\n\nIn the following cell, use the `iterrows()` function available for the `product_df` DataFrame to loop over each row of `product_df`, storing the row's `product_name` value as a key mapped to the row's `price` value within the `LinearHashTable` object named `linear_ht` (created for you at the beginning of the cell):", "3l8lKN5e7-Lr": "# @title Q2.2.1-solution\nlinear_ht = LinearHashTable()\n\nfor row_index, row in product_df.iterrows():\n  cur_product_name = row['product_name']\n  cur_price = row['price']\n  linear_ht.add(cur_product_name, cur_price)\n\n# Do not modify the following line or add any code below it, please!\nprint(linear_ht)", "rYszASNm8ebG": "# @title Q2.2.1-public\nassert 'linear_ht' in vars(), \"\u274c No variabled named 'linear_ht' exists in Python memory\"", "yK5KGyY78wk5": "#### Question 2.2.2\n\nNow, in the following cell, take the `retrieval_steps` defined for you in the first line, and use the `iterrows()` function again to loop over each element in `product_df`, but this time use your `find_item_steps()` function to compute the number of steps that are required to find each of the items in `product_df`. So, each iteration of your loop should add a new `int` value to the `retrieval_steps` list. The last line of code in the cell (already provided for you) should just take the elements you've now added to `retrieval_steps` and find the **mean number of operations** required to find the price for an inventory item. You should get a value between `37` and `38`!", "Q89ESERM8xvn": "# @title Q2.2.2-solution\nretrieval_steps_linear = []\n\nfor row_index, row in product_df.iterrows():\n  cur_name = row['product_name']\n  #print(cur_name)\n  cur_steps = linear_ht.find_item_steps(cur_name)\n  #print(cur_steps)\n  retrieval_steps_linear.append(cur_steps)\n\n# Don't modify the following line or add any code below it, please!\nmean_retrieval_steps_linear = -1\nif len(retrieval_steps_linear) > 0:\n  mean_retrieval_steps_linear = sum(retrieval_steps_linear) / len(retrieval_steps_linear)\nprint(mean_retrieval_steps_linear)", "8U0wOUJP9w_G": "# @title Q2.2.2-public\n# Test 1: mean_retrieval_steps_linear is defined\nassert 'mean_retrieval_steps_linear' in vars(), \"No variable named 'mean_retrieval_steps_linear' exists in Python memory\"\n# Test 2: mean_retrieval_steps_linear is computed, so that it does not have the default value -1\nassert mean_retrieval_steps_linear > -1, \"mean_retrieval_steps_linear should be non-negative\"", "myN7SkoiC4_D": "## Part 3: Binary Search Trees\n\nNow that you have an actually-usable Linear Hash Table, it's time to put on your **algorithmic design patterns** hat!\n\nWe saw in class how, while a **linear** approach to search requires $O(n)$ time, we can often set up our structure in such a way as to allow a **divide-and-conquer** approach to search achieving $O(n\\log_2(n))$ time. For this part, you will put this into practice by taking the `LinkedList` from HW1 and **transforming** it into a `BinarySearchTree`. Then, once you've implemented and tested this `BinarySearchTree` class, in the next part you'll use it to **improve the runtime** of your Hash Table from the previous part!\n\nHowever, as we talked about in class, when we move from `LinkedList` as our dynamically-sized data structure for handling collisions to `BinarySearchTree`, we'll need a way to ensure that the **keys** being added to our hash table have a defined **order** (so that we know whether to add an entry to the **left** or **right** subtrees of a given node!). So, to ensure that the items being added to our `BinarySearchTree` are **orderable**, run the following cell, which defines an `InventoryItem` class containing all of the ordering functions we discussed in class: `__eq__()`, `__neq__()`, `__lt__()`, `__le__()`, `__gt__()`, and `__ge__()`.", "hrkLf5nRBmSV": "# @title define-inventory-item\nclass InventoryItem:\n  def __init__(self, item_name_arg, price_arg):\n    self.item_name = item_name_arg\n    self.price = price_arg\n\n  def __lt__(self, other): # -> [NotImplemented | bool]:\n    if isinstance(other, InventoryItem):\n      return self.item_name < other.item_name\n    if isinstance(other, str):\n      return self.item_name < other\n    return NotImplemented\n\n  def __le__(self, other): # -> [NotImplemented | bool]\n    if isinstance(other, InventoryItem):\n      return self.item_name <= other.item_name\n    if isinstance(other, str):\n      return self.item_name <= other\n    return NotImplemented\n\n  def __gt__(self, other): # -> [NotImplemented | bool]\n    if isinstance(other, InventoryItem):\n      return self.item_name > other.item_name\n    if isinstance(other, str):\n      return self.item_name > other\n    return NotImplemented\n\n  def __ge__(self, other): # -> [NotImplemented | bool]\n    if isinstance(other, InventoryItem):\n      return self.item_name >= other.item_name\n    if isinstance(other, str):\n      return self.item_name >= other\n    return NotImplemented\n\n  def __eq__(self, other): # -> [NotImplemented | bool]\n    if isinstance(other, InventoryItem):\n      return self.item_name == other.item_name\n    if isinstance(other, str):\n      return self.item_name == other\n    return NotImplemented\n\n  def __ne__(self, other): # -> [NotImplemented | bool]\n    if isinstance(other, InventoryItem):\n      return self.item_name != other.item_name\n    if isinstance(other, str):\n      return self.item_name != other\n    return NotImplemented\n\n  def __repr__(self) -> str:\n    return self.__str__()\n\n  def __str__(self) -> str:\n    return f'InventoryItem[item_name={self.item_name},price={self.price}]'", "xWdMcivnBtWf": "### Part 3.1: Implementing `BinarySearchTree`\n\n#### The `BinarySearchTree` Class:\n\nIn the following cell, fill in the remaining parts of the provided starter code, by implementing the following functions within the `BinarySearchTree` class:\n\n* `__init__(self)`:\n  * Since the `BinarySearchTree` class serves mainly as a **wrapper** around the `BSTNode` class, the only thing this constructor function needs to do is initialize an instance variable called `root` and assign it the value `None` (representing that, upon construction, the binary search tree is **empty**)\n* `add(self, item: InventoryItem) -> bool`\n  * This function should take in `item`, which (as indicated by the type hint) should be an object of type `InventoryItem`, so that we can be sure that the items added to our tree have a defined **ordering**. However, since Python does not enforce type hints, your code should **explicitly check** whether or not `item` is an instance of the `InventoryItem` type, and return the `bool` value `False` if it is not. Once you've ensured that `item` is indeed an object of type `InventoryItem`, this function should proceed by just setting the `root` instance variable to point to a new `BSTNode` object (this will involve calling the `BSTNode` constructor, described below) containing the passed-in `InventoryItem` object `item`.\n  * Also note that the function in `LinkedList` was called **`append()`**, while this function is instead called **`add()`**. This is because, we're no longer \"appending\" when we add items to a binary search tree, since there's no single \"end\" that we can add a new item \"after\".\n* `find_item_steps(self, item: InventoryItem)`\n  * This function should require significantly fewer lines of code than the `add()` function! As was the case with the `LinearHashTable` above, the job of this function is just to return the number of computational steps required to find the `InventoryItem` object `item` within the binary search tree.\n* `__repr__()` and `__str__()`: You need to define these functions, but as you've done thus far, they should just work as follows:\n  * `__str__()` should return the result of calling the provided `to_string()` function with the `recurse` argument set to be the `bool` value `True`, while\n  * `__repr__()` should return the result of calling the provided `to_string()` function with the `recurse` argument set to be the `bool` value `False`.\n\n#### The `BSTNode` Class:\n\nNow, implement the following functions within the `BSTNode` class, which we've started for you in the following cell immediately after the definition of `BinarySearchTree`:\n\n* `__init__(self, item: InventoryItem)`: This constructor function should:\n  * First take the `item` argument and store it in an instance variable called `content`, then\n  * Initialize two additional instance variables, one called `left` and the other called `right`, and assign them the value `None`.\n* `add(self, new_item: InventoryItem)`: This function should be built around an **`if` statement** that should check for **three cases**:\n  * (A) The argument `new_item` is **less than** the value stored in this node's `content` instance variable, (B) the argument `new_item` is **greater than** the value stored in this node's `content` instance variable, or (C) the argument `new_item` is **equal to** the value stored in this node's `content` instance variable.\n  * In case (A), `new_item` should be added to the **left subtree** of this node. This means that you will need to perform one additional check: if the `self.left` instance variable points to the value `None`, then there **is** no left subtree, so you'll need to create it by constructing a new `BSTNode` object (whose content is constructed to be `new_item` and assigning this `BSTNode` object as the value of `self.left`. Otherwise, if `self.left` doesn't point to `None`, you should just provide `new_item` as an argument to `self.left.add()`.\n  * In case (B), `new_item` should be added to the **right subtree** of this node. This means that you will need to perform one additional check: if the `self.right` instance variable points to the value `None`, then there **is** no right subtree, so you'll need to create it by constructing a new `BSTNode` object (whose content is constructed to be `new_item` and assigning this `BSTNode` object as the value of `self.right`. Otherwise, if `self.right` doesn't point to `None`, you should just provide `new_item` as an argument to `self.right.add()`.\n  * If we're in case (C), this means that an item with the same **key** has already been added to the tree, so that instead of creating a new `BSTNode` or calling `add()`, we just **update the value of `self.content`** to be `new_item`.\n* `find_item_steps(self, item: InventoryItem) -> int`: This function has the same explanation as was given for the `find_item_steps()` function in `BinarySearchTree` class above, but in this case you'll need to actually check the **content** (the `self.content`) of the `BSTNode`, to see whether or not we've indeed **found** the item within this `BSTNode`. Otherwise, we'll need to return the sum of:\n  * `1`, representing the check we did of the `BSTNode`'s content, and then\n  * `0` if `item` **precedes** this `BSTNode`'s content but this `BSTNode` has no left child,\n  * The result of `left.find_item_steps()` if `item` **precedes** this `BSTNode`'s content and this `BSTNode` **does** have a left child,\n  * `0` if `item` **comes after** this `BSTNode`'s content but this `BSTNode` has no right child, or\n  * The result of `right.find_item_steps()` if `item` **comes after** this `BSTNode`'s content and this `BSTNode` **does** have a left child.\n* `__repr__(self) -> str` and `__str__(self) -> str`: You need to define these functions, but as you've done thus far, they should just work as follows:\n  * `__str__()` should return the result of calling the provided `to_string()` function with the `recurse` argument set to be the `bool` value `True`, while\n  * `__repr__()` should return the result of calling the provided `to_string()` function with the `recurse` argument set to be the `bool` value `False`.\n\nKeep in mind that we defined a **complete ordering** for objects of type `InventoryItem` above (in the definition of the `InventoryItem` class), so that for both `add()` and `find_item_steps()` you don't need to ever look \"inside\" the `InventoryItem` object! You can just use Python operators like `<`, `==`, and `>` to check whether you've found `item`, and if not, whether the search should continue within the **left** or **right subtrees** of the `BSTNode`.", "shhxCawRCj-u": "# @title Q3.1-solution\nclass BinarySearchTree:\n  def __init__(self):\n    self.root = None\n\n  def add(self, new_item: InventoryItem) -> bool:\n    if self.root is None:\n      self.root = BSTNode(new_item)\n      return True\n    else:\n      return self.root.add(new_item)\n\n  def find_item_steps(self, item: InventoryItem) -> int:\n    return self.root.find_item_steps(item)\n\n  def __len__(self) -> int:\n    if self.root is None:\n      return 0\n    return len(self.root)\n\n  def to_string(self, recurse: bool) -> str:\n    if self.root is None:\n      return 'BinarySearchTree[]'\n    return f'BinarySearchTree[{self.root.to_string(recurse)}]'\n\n  def __repr__(self) -> str:\n    return self.to_string(recurse=False)\n\n  def __str__(self) -> str:\n    return self.to_string(recurse=True)\n\nclass BSTNode:\n  def __init__(self, item: InventoryItem):\n    self.content = item\n    self.left = None\n    self.right = None\n\n  def add(self, new_item: InventoryItem) -> bool:\n    if new_item < self.content:\n      # Add to left subtree\n      if self.left is None:\n        self.left = BSTNode(new_item)\n        return True\n      else:\n        return self.left.add(new_item)\n    elif new_item > self.content:\n      # Add to right subtree\n      if self.right is None:\n        self.right = BSTNode(new_item)\n        return True\n      else:\n        return self.right.add(new_item)\n    else:\n      # Equal, so we update the content here itself\n      self.content = new_item\n\n  def find_item_steps(self, item) -> int:\n    if self.content == item:\n      return 1\n    if item < self.content:\n      return 1 + self.left.find_item_steps(item)\n    return 1 + self.right.find_item_steps(item)\n\n  def has_left_child(self) -> bool:\n    return self.left is not None\n\n  def get_left_child(self): # -> BSTNode\n    return self.left\n\n  def has_right_child(self) -> bool:\n    return self.right is not None\n\n  def get_right_child(self): # -> BSTNode\n    return self.right\n\n  def __len__(self) -> int:\n    content_len = 1\n    left_len = 0 if self.left is None else len(self.left)\n    right_len = 0 if self.right is None else len(self.right)\n    return content_len + left_len + right_len\n\n  def to_string(self, recurse: bool) -> str:\n    if recurse:\n      left_str = \"\" if self.left is None else self.left.__repr__() + \",\"\n      right_str = \"\" if self.right is None else \",\" + self.right.__repr__()\n      return f'{left_str}{str(self.content)}{right_str}'\n    else:\n      return str(self.content)\n\n  def __repr__(self) -> str:\n    return self.to_string(recurse=False)\n\n  def __str__(self) -> str:\n    return self.to_string(recurse=True)", "QTEVr8d5SRv2": "# @title Q3.1-public\n# Test 1: Check if BinarySearchTree class defined\nassert 'BinarySearchTree' in vars(), \"\u274c BinarySearchTree not defined in Python memory\"", "-Ykq4kHaQ5YL": "## Part 3.2: Iterating over BSTs\n\nYou may be eager to check out the contents of your BST from Part 3 right away! But, it also may suddenly dawn on you: when we were working with LinkedLists, we could print all the contents by just \"looping through\" the list, from one element to the next, printing as we go along. But... for a BinarySearchTree, since our structure can now **branch** as we traverse it... How do we \"loop through\" a BST?\n\nThe answer is not entirely straightforward, but it boils down to the following: there are **two different ways** to loop over our BST, and since they are \"opposites\" of each other (in an intuitive but also a formal-mathematical sense!), your job as a data scientist is to **think carefully** about which one is **more efficient** for a given goal! The two methods are:\n\n1. **Depth-First Search (DFS)**: With this approach, we iterate through the BST by **always taking the left child as the \"next\" child** until we hit a **leaf node** (which means, we cannot follow this left-child pointer any longer, since a leaf node does not have a left child or a right child!), and only at that point do we **back up** and take the **right children** we skipped.\n2. **Breadth-First Search (BFS)**: This is the **\"opposite\"** of DFS in the sense that we traverse the tree level-by-level, **never moving to the next level of the tree** until we're **sure that we have visited every node on the current level**.\n\nThose are just rough descriptions of the process to start building your intution, however. Since both concepts invoke the notion of **\"moving\"** through a tree, **animations** can illustrate the two far better than any static, textual description can, in my view. So, take a look at the following animations and try to match what's happening in each of them with the two textual descriptions above, before moving on:\n\n**Depth-First Search** (from <a href='https://jjacobs.me/dsan5500/w05/slides.html#/two-ways-to-traverse-animated-version' target='_blank'>Week 5 slides</a>)\n\n![](https://jjacobs.me/dsan5500/w05/images/Depth-First-Search.gif)\n\n**Breadth-First Search** (from <a href='https://jjacobs.me/dsan5500/w05/slides.html#/two-ways-to-traverse-animated-version' target='_blank'>Week 5 slides</a>)\n\n![](https://jjacobs.me/dsan5500/w05/images/Breadth-First-Search.gif)\n\nNow that you have an intuition for the difference between DFS and BFS, you may be thinking that they might require very different code to implement---but this is where the **mathematical-formal linkage** between the two (mentioned above, parenthetically) become ultra helpful! It turns out---and if you take a full-on algorithmic theory course you learn how to formally prove---that\n\n1. **Depth-First Search** can be accomplished by **processing nodes in an order determined by adding each to a *stack***, while\n2. **Breadth-First Search** can be accomplished by **processing nodes in an order determined by adding each to a *queue***!\n\nThis means, quite literally, that the difference between performing DFS and BFS solely boils down to taking identical code but \"pulling out\" the word **stack** and replacing it with the word **queue** within your code (or vice-versa to switch back).\n\nSo, if you have your Software Engineer Hats on, you'll recognize that this is the perfect case for implementing an **abstraction layer!**\n\nSpecifically, we will make a class called `NodeProcessor`, which simply allows nodes to be \"put into\" it and \"taken out of\" it, but which can **switch** between a **stack** and a **queue** as its underlying data structure, based on whether the user wants to perform a DFS or BFS on their tree.", "GfbN5ZFAFf2c": "First, run the following cell, which defines a `visualize_bst()` function you can use for exploration or for debugging, which takes in a `BinarySearchTree` object and produces a visualization of the tree in the same format I've been using to draw binary search trees on the board in class:", "ImAVp_y6Fz2G": "# @title define-bst-visualizer\ndef visualize_bst(tree):\n    dot = Digraph(\n        node_attr={'shape': 'record', 'height': '.1'}\n    )\n    node_info_list = []\n    if tree.root is not None:\n      node_info_list.append({'node':tree.root, 'parent_name': None, 'dir': None})\n    while len(node_info_list) > 0:\n      cur_node_info = node_info_list.pop()\n      cur_node = cur_node_info['node']\n      cur_name = cur_node.content.item_name\n      cur_parent_name = cur_node_info['parent_name']\n      cur_dir = cur_node_info['dir']\n      dot.node(name=cur_name, label=nohtml(f'<f0>|<f1> {cur_name}|<f2>'))\n      if cur_parent_name is not None:\n        # Nudge x coord based on parent\n        which_port = 'f0'\n        if cur_dir == 'R':\n          which_port = 'f2'\n        edge_from = f'{cur_parent_name}:{which_port}'\n        edge_to = f'{cur_name}:f1'\n        dot.edge(edge_from, edge_to, label=cur_dir)\n      if cur_node.right is not None:\n        node_info_list.append({'node': cur_node.right, 'parent_name': cur_name, 'dir': 'R'})\n      if cur_node.left is not None:\n        node_info_list.append({'node': cur_node.left, 'parent_name': cur_name, 'dir': 'L'})\n    display(dot)", "SrJHRZc0DEC6": "# @title define-thing-container\nclass ThingContainer:\n  def __init__(self):\n    self.internal_list = []\n\n  @abstractmethod\n  def put_new_thing_in(self, item):\n    pass\n\n  def is_empty(self) -> bool:\n    return self.__len__() == 0\n\n  def __len__(self):\n    return len(self.internal_list)\n\n  @abstractmethod\n  def take_existing_thing_out(self):\n    pass\n\nclass Stack(ThingContainer):\n  def __init__(self):\n    super().__init__()\n\n  def __push(self, item):\n    self.internal_list.append(item)\n\n  def __pop(self):\n    return self.internal_list.pop()\n\n  def put_new_thing_in(self, item):\n    return self.__push(item)\n\n  def take_existing_thing_out(self):\n    return self.__pop()\n\nclass Queue(ThingContainer):\n  def __init__(self):\n    super().__init__()\n\n  def put_new_thing_in(self, item):\n    return self.__enqueue(item)\n\n  def __enqueue(self, item):\n    self.internal_list.insert(0, item)\n\n  def __dequeue(self):\n    return self.internal_list.pop()\n\n  def take_existing_thing_out(self):\n    return self.__dequeue()", "8tygaDB7Q5CC": "# @title Q3.2.1-solution\nfrom abc import ABC\nfrom enum import Enum\n\nclass IterAlgorithm(Enum):\n  DEPTH_FIRST = 1\n  BREADTH_FIRST = 2\n\nclass NodeProcessor():\n  def __init__(self, iter_method_arg: IterAlgorithm):\n    self.iter_method = iter_method_arg\n    self.initialize_empty_node_container()\n\n  def initialize_empty_node_container(self):\n    if self.iter_method == IterAlgorithm.DEPTH_FIRST:\n      self.node_container = Stack()\n    else:\n      self.node_container = Queue()\n\n  def iterate_over(self, tree):\n    self.initialize_empty_node_container()\n    cur_node = tree.root\n    self.node_container.put_new_thing_in(cur_node)\n    while not self.node_container.is_empty():\n      cur_node = self.node_container.take_existing_thing_out()\n      # add left child to the queue\n      if cur_node.has_left_child():\n        self.node_container.put_new_thing_in(cur_node.left)\n      if cur_node.has_right_child():\n        self.node_container.put_new_thing_in(cur_node.right)\n      print(cur_node.content)", "uhXAD0zcSMsf": "# @title Q3.2.1-public\n# Test 1: Check if NodeProcessor class defined\nassert 'NodeProcessor' in vars(), \"\u274c NodeProcessor not defined in Python memory\"", "w9BL9PUKDVHD": "### Question 3.2.2\n\nIf your implementation of `iterate_over(tree)` is correct, you should now be able to run the following cell to see how your implementation can produce **both** a breadth-first and depth-first iteration over the tree you constructed in the previous part, with the same code!", "fjj6WwLODTa5": "# @title Q3.2.2-solution\nbst = BinarySearchTree()\nitem1 = InventoryItem('Mango', 50)\nbst.add(item1)\nitem2 = InventoryItem('Pickle', 60)\nbst.add(item2)\nitem3 = InventoryItem('Artichoke', 55)\nbst.add(item3)\nitem4 = InventoryItem('Zebra', 3)\nbst.add(item4)\nitem5 = InventoryItem('Banana', 123)\nbst.add(item5)\nitem6 = InventoryItem('Aardvark', 11)\nbst.add(item6)\nvisualize_bst(bst)\nprint(\"\\n---\\n\")\n\nimport io\nfrom contextlib import redirect_stdout\nwith redirect_stdout(io.StringIO()) as q3_2_2_response:\n  print(\"DFS:\")\n  dfs_processor = NodeProcessor(IterAlgorithm.DEPTH_FIRST)\n  print(type(dfs_processor.node_container))\n  dfs_processor.iterate_over(bst)\n\n  print(\"\\nBFS:\")\n  bfs_processor = NodeProcessor(IterAlgorithm.BREADTH_FIRST)\n  print(type(bfs_processor.node_container))\n  bfs_processor.iterate_over(bst)\nprint(q3_2_2_response.getvalue())", "HIsAociP-Tgl": "# @title Q3.2.2-public\n# Test 1: Make sure response output was captured in variable called q3_2_2_response\nassert 'q3_2_2_response' in vars(), \"\u274c No variable named 'q3_2_2_response' exists in Python memory\"", "6jfoiSCPDffb": "## Part 4: Hash Tables with Logarithmic Collision Handling\n\nNow that you have a `BinarySearchTree` within which elements can be found in $O(\\log_2(n))$ time rather than the $O(n)$ time that was possible with `LinkedList`, in this part you will **use** this `BinarySearchTree` class as the structure that your **Hash Table** will construct whenever a collision occurs. In this way, then, by **leveraging** the improvements of the `BinarySearchTree` over the `LinkedList`, you will also \"automatically\" achieve an improvement in the runtime (for search) of `LogarithmicHashTable` over `LinearHashTable`!", "2nA4OlqAC_x-": "# @title Q4.1-solution\nclass LogarithmicHashTable:\n  def __init__(self):\n    self.hasher = AlphaHasher()\n    self.fixed_array_size = self.hasher.get_alphabet_size()\n    self.fixed_length_array = np.empty(self.fixed_array_size, dtype=object)\n    self.num_added = 0\n    self.num_collisions = 0\n\n  def add(self, key: str, value: object) -> bool:\n    if not isinstance(key, str):\n      return False\n    data = InventoryItem(key, value)\n    key_hash = self.hasher.hash(key)\n    if self.fixed_length_array[key_hash] is None:\n      # All good, we can add without collision\n      self.fixed_length_array[key_hash] = data\n      self.num_added = self.num_added + 1\n      return True\n    if isinstance(self.fixed_length_array[key_hash], BinarySearchTree):\n      # Already a collision previously, so LinkedList has already been set up;\n      # This is another collision, but we can just add to the existing LinkedList\n      self.increment_num_collisions()\n      self.fixed_length_array[key_hash].add(data)\n      self.increment_num_added()\n      return True\n    # If we're here, it's a collision *but* the first collision in this slot;\n    # so, we need to set up the LinkedList, add the item currently in the slot\n    # as its first element, then add `data` as its second element\n    self.increment_num_collisions()\n    original_data = self.fixed_length_array[key_hash]\n    self.fixed_length_array[key_hash] = BinarySearchTree()\n    self.fixed_length_array[key_hash].add(original_data)\n    self.fixed_length_array[key_hash].add(data)\n    self.increment_num_added()\n    return True\n\n  def find_item_steps(self, item: InventoryItem) -> int:\n    key_hash = self.hasher.hash(item.item_name)\n    if self.fixed_length_array[key_hash] is None:\n      return 0\n    if isinstance(self.fixed_length_array[key_hash], InventoryItem):\n      return 1\n    return self.fixed_length_array[key_hash].find_item_steps(item)\n\n  def entry_to_string(self, index: int, recurse: bool) -> object:\n    item_at_index = self.fixed_length_array[index]\n    if item_at_index is None:\n      return None\n    elif isinstance(item_at_index, InventoryItem):\n      return item_at_index\n    else:\n      return item_at_index.to_string(recurse)\n\n  def get_num_added(self):\n    return self.num_added\n\n  def increment_num_added(self):\n    self.num_added = self.num_added + 1\n\n  def get_num_collisions(self):\n    return self.num_collisions\n\n  def increment_num_collisions(self):\n    self.num_collisions = self.num_collisions + 1\n\n  def __len__(self):\n    total_len = 0\n    for cur_entry in self.fixed_length_array:\n      if cur_entry is None:\n        continue\n      elif isinstance(cur_entry, InventoryItem):\n        total_len = total_len + 1\n      else:\n        total_len = total_len + len(cur_entry)\n    return total_len\n\n  def to_string(self, recurse):\n    entry_list = [f'{self.hasher.compute_key_for_index(i)}: {self.entry_to_string(i, recurse)}' for i in range(len(self.fixed_length_array))]\n    return \"\\n\".join(entry_list)\n\n  def __str__(self):\n    return self.to_string(recurse=True)\n\n  def __repr__(self):\n    return self.to_string(recurse=False)", "0zzp26bkSGKt": "# @title Q4.1-public\n# Test 1: Check if LogarithmicHashTable defined in Python memory\nassert 'LogarithmicHashTable' in vars(), \"\u274c LogarithmicHashTable not defined in Python memory\"", "YGANaDvh-eYV": "### Part 4.2: Using `LogarithmicHashTable`", "8PB_OG08Gdck": "Now, as you've done before, run the following cell to load the (fake) product data into a Pandas `DataFrame` object called `product_df_log`, and use the `iterrows()` function to loop over each element in `product_df_log` and add it into the `LogarithmicHashTable` object called `log_ht` we've created for you in the first line of the `Q4.2-response` cell below.", "VF5ltznfGcWY": "# @title Q4.2.1-solution\nimport pandas as pd\nproduct_df_log = pd.read_csv(\"https://jpj.georgetown.domains/dsan5500-scratch/mockaroo.csv\")\nproduct_df_log.head()\nlogarithmic_ht = LogarithmicHashTable()\n\n# Your code here\nfor row_index, row in product_df_log.iterrows():\n  cur_name = row['product_name']\n  cur_price = row['price']\n  logarithmic_ht.add(cur_name, cur_price)\n\n# Do not modify or add code below the following lines, please!\nlogarithmic_ht", "u5AQUraqMWsQ": "# @title Q4.2.1-public\nassert 'logarithmic_ht' in vars(), \"\u274c No variable named 'logarithmic_ht' exists in Python memory\"", "MHB74Rpq-jCd": "#### Question 4.2.2: Testing the Efficiency of `LogarithmicHashTable`", "TNYNeBnUHc96": "And, just as you did in earlier parts, now loop over each row of `product_df` and use the `find_item_steps()` function you wrote as part of the `LogarithmicHashTable` class above to compute the number of operations required to find each item in `logarithmic_ht`, storing the result of each loop iteration in `", "PzKD0EuwHcUx": "# @title Q4.2.2-solution\nretrieval_steps_log = []\n\nfor row_index, row in product_df_log.iterrows():\n  cur_name = row['product_name']\n  cur_price = row['price']\n  cur_item = InventoryItem(cur_name, cur_price)\n  cur_steps = logarithmic_ht.find_item_steps(cur_item)\n  retrieval_steps_log.append(cur_steps)\n\n# Don't modify the following line or add any code below it, please!\nmean_retrieval_steps_log = -1\nif len(retrieval_steps_log) > 0:\n  mean_retrieval_steps_log = sum(retrieval_steps_log) / len(retrieval_steps_log)\nprint(mean_retrieval_steps_log)", "pd5N3Zy6L1W-": "# @title Q4.2.2-public\n# Test 1: Make sure retrieval_steps_log is defined\nassert 'retrieval_steps_log' in vars(), \"\u274c No variabled named 'retrieval_steps_log' exists in Python memory\"\n# Test 2: Check that retrieval_steps_log contains a number of steps for each row in product_df\nassert len(retrieval_steps_log) == len(product_df), f\"'retrieval_steps_log' should have the same length as 'product_df' ({len(product_df)})\"", "H9UqwiXURPUd": "## Part 5: A Push Towards $O(1)$\n\nFor this final part, as mentioned in class, we will get **even closer to $O(1)$ time retrieval** by just allocating more memory slots for the fixed-length array used by our hash table, hashing the added keys based on the first **two letters** of the key rather than just the first letter as we've done thus far.\n\nTo accomplish this, we'll need a new version of the `AlphaHasher` class that we used previously, that will hash keys based on the first two letters rather than just the first letter. Run the following cell, which defines a new `AlphaHasher2` class implementing this hash function:", "wgIOgkJIEsFM": "# @title define-alpha-hasher-2\nclass AlphaHasher2(CustomHasher):\n  def __init__(self):\n    self.alphabet_size = 26 * 26\n\n  def get_alphabet_size(self):\n    return self.alphabet_size\n\n  def hash(self, str_to_hash: str) -> int:\n    if len(str_to_hash) == 0:\n      first_two_letters = 'AA'\n    elif len(str_to_hash) == 1:\n      first_letter = str_to_hash.upper()[0]\n      second_letter = 'A'\n    else:\n      first_letter = str_to_hash.upper()[0]\n      second_letter = str_to_hash.upper()[1]\n    #print(f'First two letters for {str_to_hash}: {first_letter}{second_letter}')\n    # And return its index:\n    # 'AA' has index 0, 'AB' has index 1, etc.\n    first_letter_pos = self.compute_position_in_alphabet(first_letter)\n    second_letter_pos = self.compute_position_in_alphabet(second_letter)\n    # The position in the two-letter alphabet is just 26*first + second\n    final_pos = 26 * first_letter_pos + second_letter_pos\n    return final_pos\n\n  def compute_position_in_alphabet(self, uppercase_key: str) -> int:\n    if uppercase_key in string.ascii_uppercase:\n      return string.ascii_uppercase.index(uppercase_key)\n    return 0\n\n  def compute_key_for_index(self, index: int) -> str:\n    first_letter_part = int(index / 26)\n    second_letter_part = index % 26\n    # In case you need to debug!\n    #print(f'alpha2_index: {index}, first_letter_part: {first_letter_part}, second_letter_part: {second_letter_part}')\n    return string.ascii_uppercase[first_letter_part] + string.ascii_uppercase[second_letter_part]", "JdYFCrd5Ev29": "### Question 5.1\n\nNow that we have our `AlphaHasher2` class, for this question, you should be able to re-use almost all of your `LogarithmicHashTable` code to make a new class `LogarithmicHashTable2`, where now the only differences should be:\n\n* (a) It is initialized with an `AlphaHasher2` object as its `hasher` instance variable (already done for you in the `__init__()` function), and\n* (b) It has a new `to_string()` function that, to avoid printing out 676 lines at once, only prints the **filled** slots within the `fixed_length_array` instance variable (also already done for you below)", "2NIDUccOhKyT": "# @title Q5.1-solution\nclass LogarithmicHashTable2:\n  def __init__(self):\n    self.hasher = AlphaHasher2()\n    self.fixed_array_size = self.hasher.get_alphabet_size()\n    self.fixed_length_array = np.empty(self.fixed_array_size, dtype='object')\n    self.num_added = 0\n    self.num_collisions = 0\n\n  def add(self, key: str, value: object) -> bool:\n    if not isinstance(key, str):\n      return False\n    data = InventoryItem(key, value)\n    key_hash = self.hasher.hash(key)\n    if self.fixed_length_array[key_hash] is None:\n      # All good, we can add without collision\n      self.fixed_length_array[key_hash] = data\n      self.num_added = self.num_added + 1\n      return True\n    if isinstance(self.fixed_length_array[key_hash], BinarySearchTree):\n      # Already a collision previously, so LinkedList has already been set up;\n      # This is another collision, but we can just add to the existing LinkedList\n      self.increment_num_collisions()\n      self.fixed_length_array[key_hash].add(data)\n      self.increment_num_added()\n      return True\n    # If we're here, it's a collision *but* the first collision in this slot;\n    # so, we need to set up the LinkedList, add the item currently in the slot\n    # as its first element, then add `data` as its second element\n    self.increment_num_collisions()\n    original_data = self.fixed_length_array[key_hash]\n    self.fixed_length_array[key_hash] = BinarySearchTree()\n    self.fixed_length_array[key_hash].add(original_data)\n    self.fixed_length_array[key_hash].add(data)\n    self.increment_num_added()\n    return True\n\n  def find_item_steps(self, item: InventoryItem) -> int:\n    key_hash = self.hasher.hash(item.item_name)\n    if self.fixed_length_array[key_hash] is None:\n      return 0\n    if isinstance(self.fixed_length_array[key_hash], InventoryItem):\n      return 1\n    return self.fixed_length_array[key_hash].find_item_steps(item)\n\n  def entry_to_string(self, index: int, recurse: bool) -> object:\n    item_at_index = self.fixed_length_array[index]\n    if item_at_index is None:\n      return None\n    elif isinstance(item_at_index, InventoryItem):\n      return item_at_index\n    else:\n      return item_at_index.to_string(recurse)\n\n  def get_num_added(self):\n    return self.num_added\n\n  def increment_num_added(self):\n    self.num_added = self.num_added + 1\n\n  def get_num_collisions(self):\n    return self.num_collisions\n\n  def increment_num_collisions(self):\n    self.num_collisions = self.num_collisions + 1\n\n  def __len__(self):\n    total_len = 0\n    for cur_entry in self.fixed_length_array:\n      if cur_entry is None:\n        continue\n      elif isinstance(cur_entry, InventoryItem):\n        total_len = total_len + 1\n      else:\n        total_len = total_len + len(cur_entry)\n    return total_len\n\n  def to_string(self, recurse):\n    # Here we only print the *non-empty* slots\n    non_empty_slots = []\n    for i in range(len(self.fixed_length_array)):\n      item_at_i = self.fixed_length_array[i]\n      if item_at_i is not None:\n        entry_letters = self.hasher.compute_key_for_index(i)\n        entry_content = self.entry_to_string(i, recurse)\n        entry_str = f'{entry_letters}: {entry_content}'\n        non_empty_slots.append(entry_str)\n    return \"\\n\".join(non_empty_slots)\n\n  def __repr__(self):\n    return self.to_string(recurse=False)\n\n  def __str__(self):\n    return self.to_string(recurse=True)", "PDYcjLQlSAq1": "# @title Q5.1-public\n# Test 1: Ensure LogarithmicHashTable2 class is defined in Python memory\nassert 'LogarithmicHashTable2' in vars(), \"\u274c LogarithmicHashTable2 not defined in Python memory\"", "UIrz7BneFMk6": "### Part 5.2: Measuring the `AlphaHasher2` Efficiency Gain\n\nNow that you have a hash table utilizing `AlphaHasher2` rather than `AlphaHasher`, repeat the steps from the end of the previous part in the next cell: adding each of the items from `product_df` one-by-one to the hash table, then computing the mean number of operations required to retrieve the price for a given item. Store this mean number of operations into a Python variable called `two_letter_efficiency`: you should find that the mean number of operations is now about **half** of the mean number of operations we achieved with `AlphaHasher` at the end of the previous part!\n\nThe takeaway of this part is therefore that we were able to **double** the efficiency of our hash table, simply by allocating more memory slots for our fixed-length array, without changing anything at all in terms of the actual **algorithm** used to store and retrieve data! So, you can now imagine how we can get arbitrarily close to $O(1)$: the hash table is exactly the data structure which illustrates the **efficiency-memory tradeoff** mentioned in the first week of class, in the sense that, we can make it more and more efficient---without any algorithmic changes---simply by allocating more and more memory to the base hash table algorithm.", "4MTSfuepLJMW": "import pandas as pd\nproduct_df = pd.read_csv(\"https://jpj.georgetown.domains/dsan5500-scratch/mockaroo.csv\")\nproduct_df.head()", "DlkGqiXwHDNi": "# @title Q5.2.1-solution\nlogarithmic_ht2 = LogarithmicHashTable2()\n\nfor row_index, row in product_df.iterrows():\n  cur_name = row['product_name']\n  cur_price = row['price']\n  logarithmic_ht2.add(cur_name, cur_price)\n\n# Do not modify the following line or add code after it, please!\nprint(logarithmic_ht2)", "KP-VP9p6HFba": "# @title Q5.2.1-public\n# Test 1: Ensure that logarithmic_ht2 is defined\nassert 'logarithmic_ht2' in vars(), \"\u274c No variable named 'logarithmic_ht2' exists in Python memory\"", "mzFsWob1fvV-": "ah2 = AlphaHasher2()\nah2.hash('Lychee'), ah2.hash('Zygote'), ah2.hash('Vodka')", "2pMP_SNvLd7o": "#### Question 5.2.2: Efficiency\n\nNow, as you've done before, complete the following code by using the `iterrows()` function to loop over each row in `product_df`, storing the number of steps required find the item in this row in `log_retrieval2`", "N__osr-_Ldag": "# @title Q5.2.2-solution\nretrieval_steps_log2 = []\n\nfor row_index, row in product_df.iterrows():\n  cur_name = row['product_name']\n  cur_price = row['price']\n  cur_item = InventoryItem(cur_name, cur_price)\n  cur_steps = logarithmic_ht2.find_item_steps(cur_item)\n  retrieval_steps_log2.append(cur_steps)\n\n# Don't modify the following lines or add any code below it, please!\nmean_retrieval_steps_log2 = -1\nif len(retrieval_steps_log2) > 0:\n  mean_retrieval_steps_log2 = sum(retrieval_steps_log2) / len(retrieval_steps_log2)\nprint(mean_retrieval_steps_log2)", "sPqBV0qZMG2j": "# @title Q5.2.2-public\n# Test 1: Ensure that mean_retrieval_steps_log2 exists in Python memory\nassert 'mean_retrieval_steps_log2' in vars(), \"\u274c No variable named 'mean_retrieval_steps_log2' exists in Python memory\"", "qEVbLvxFRR7u": "You did it! Thank you for your hard work making it to the end. Now make sure you save that hard work, then go back into Google Classroom and use the big blue \"Hand In\" button to submit to the autograder and obtain your hidden-test report.\n\n**NOTE** that, once you click \"Hand In\", Google Classroom modifies the permissions for your .ipynb file such that it is \"owned\" by the group of instructors. So, once you receive your results, you'll have to go back to the same part of the interface and **click \"Unsubmit\" to transfer the ownership of the .ipynb back to yourself**, so that you can continue working on the Colab notebook file!"}
